{"version":3,"file":"useIntersectionObserver-Dp7KdSfc.js","sources":["../../../src/hooks/useIntersectionObserver.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport type { MutableRefObject } from 'react';\n\ntype UseIntersectionObserverOptions = IntersectionObserverInit & {\n  once?: boolean;\n  triggerOnce?: boolean; // Alias for 'once' for backward compatibility\n};\n\ntype UseIntersectionObserverResult<T extends Element> = {\n  ref: MutableRefObject<T | null>;\n  elementRef: MutableRefObject<T | null>; // Alias for backward compatibility\n  isIntersecting: boolean;\n  isVisible: boolean; // Alias for backward compatibility\n};\n\n/**\n * Hook to detect when an element enters the viewport\n * Supports both ref and elementRef, isIntersecting and isVisible for compatibility\n */\nexport function useIntersectionObserver<T extends Element>(\n  options: UseIntersectionObserverOptions = {}\n): UseIntersectionObserverResult<T> {\n  const { once = true, triggerOnce = once, ...observerOptions } = options;\n  const { root, rootMargin, threshold } = observerOptions;\n  const thresholdKey = Array.isArray(threshold) ? threshold.join(',') : (threshold ?? '0');\n  const ref = useRef<T | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  useEffect(() => {\n    const target = ref.current;\n\n    if (!target) {\n      return;\n    }\n\n    if (typeof IntersectionObserver === 'undefined') {\n      setIsIntersecting(true);\n      return;\n    }\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsIntersecting(true);\n          if (triggerOnce) {\n            observer.disconnect();\n          }\n        } else if (!triggerOnce) {\n          setIsIntersecting(false);\n        }\n      },\n      { root, rootMargin, threshold }\n    );\n\n    observer.observe(target);\n\n    return () => observer.disconnect();\n  }, [triggerOnce, root, rootMargin, thresholdKey, threshold]);\n\n  return {\n    ref,\n    elementRef: ref, // Alias for backward compatibility\n    isIntersecting,\n    isVisible: isIntersecting, // Alias for backward compatibility\n  };\n}\n"],"names":["useIntersectionObserver","options","once","triggerOnce","observerOptions","root","rootMargin","threshold","thresholdKey","ref","useRef","isIntersecting","setIsIntersecting","useState","useEffect","target","observer","entry"],"mappings":"wCAmBO,SAASA,EACdC,EAA0C,GACR,CAClC,KAAM,CAAE,KAAAC,EAAO,GAAM,YAAAC,EAAcD,EAAM,GAAGE,GAAoBH,EAC1D,CAAE,KAAAI,EAAM,WAAAC,EAAY,UAAAC,CAAA,EAAcH,EAClCI,EAAe,MAAM,QAAQD,CAAS,EAAIA,EAAU,KAAK,GAAG,EAAKA,GAAa,IAC9EE,EAAMC,EAAAA,OAAiB,IAAI,EAC3B,CAACC,EAAgBC,CAAiB,EAAIC,EAAAA,SAAS,EAAK,EAE1DC,OAAAA,EAAAA,UAAU,IAAM,CACd,MAAMC,EAASN,EAAI,QAEnB,GAAI,CAACM,EACH,OAGF,GAAI,OAAO,qBAAyB,IAAa,CAC/CH,EAAkB,EAAI,EACtB,MACF,CAEA,MAAMI,EAAW,IAAI,qBACnB,CAAC,CAACC,CAAK,IAAM,CACPA,EAAM,gBACRL,EAAkB,EAAI,EAClBT,GACFa,EAAS,WAAA,GAEDb,GACVS,EAAkB,EAAK,CAE3B,EACA,CAAE,KAAAP,EAAM,WAAAC,EAAY,UAAAC,CAAA,CAAU,EAGhC,OAAAS,EAAS,QAAQD,CAAM,EAEhB,IAAMC,EAAS,WAAA,CACxB,EAAG,CAACb,EAAaE,EAAMC,EAAYE,EAAcD,CAAS,CAAC,EAEpD,CACL,IAAAE,EACA,WAAYA,EACZ,eAAAE,EACA,UAAWA,CAAA,CAEf"}