{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Imadlab Blog",
  "home_page_url": "https://imadlab.me",
  "feed_url": "https://imadlab.me/feed.json",
  "description": "Technical notes on industrial AI systems, procedural extraction, architecture, and evaluation.",
  "items": [
    {
      "id": "https://imadlab.me/blogs/evaluation-beyond-accuracy-constraint-coverage-and-safety",
      "url": "https://imadlab.me/blogs/evaluation-beyond-accuracy-constraint-coverage-and-safety",
      "title": "Evaluation Beyond Accuracy: Constraint Coverage and Safety",
      "summary": "Why standard NLP accuracy numbers are not enough for industrial procedure extraction, and what to measure instead.",
      "tags": [
        "evaluation",
        "industrial-ai",
        "safety",
        "procedural-knowledge-extraction",
        "reliability"
      ],
      "date_published": "2026-02-04T09:10:00.000Z",
      "date_modified": "2026-02-04T09:10:00.000Z",
      "content_text": "Most extraction systems look acceptable if you only report one headline number. I have made that reporting mistake myself, and it hides the real risk. In industrial procedure support, a model can score well on overlap-style metrics and still fail where risk is concentrated: conditions, prohibitions, and exception logic. If evaluation ignores that gap, teams get a false sense of readiness. The limits of standard \"accuracy\" For procedural tasks, classic metrics can over-reward the easy parts: - action verbs, - frequent entities, - common step patterns. The hard parts are less frequent but more important: - threshold conditions, - decision branches, - exception paths, - role-specific approvals. If a system misses one high-risk guard and captures twenty low-risk steps, aggregate accuracy can still look strong. Operationally, that is still a failing system. A metric suite aligned with risk I use a metric set that separates structural correctness from safety-critical fidelity. | Metric | What it checks | Why it matters | | --- | --- | --- | | Step F1 | Core step extraction quality | Baseline structural coverage | | Adjacency fidelity | Correct step ordering and transitions | Process logic continuity | | Constraint coverage | Recovery of required conditions and guards | Safety-critical completeness | | Decision-point fidelity | Preservation of branch nodes and branch criteria | Correct behavior under variation | | Exception recall | Capture of warnings and prohibited actions | Prevents silent hazardous omissions | | Traceability score | Presence of source-span evidence per extracted claim | Supports audit and review | This split makes failures visible where aggregate metrics hide them. Severity weighting changes decisions Not all errors are equal. Missing a unit label and missing a lockout precondition should not carry the same penalty. I recommend assigning severity classes in the gold standard: - Critical : omission can directly affect safety-critical action. - Major : omission can degrade decision quality or compliance. - Minor : omission has low operational consequence. Then compute a severity-weighted error index alongside base metrics. Simple form: Use weights that domain experts agree on, not arbitrary values decided only by engineers. Constraint coverage should be explicit Constraint coverage is often treated as a side metric. In my experience, it should be a primary release gate for procedural systems. Practical definition: But matching needs discipline: - match by semantic equivalence, not only string overlap, - require linkage to the correct step, - verify scope boundaries when the same term appears in multiple sections. A condition extracted in the wrong place is not a partial success. It is a structural error. Evaluation protocol that scales A useful protocol for applied research-to-pilot work: 1. Build a gold set with mixed complexity (easy, medium, edge-case documents). 2. Annotate steps, transitions, constraints, exceptions, and severity labels. 3. Run extraction with fixed config and seeded decoding for reproducibility. 4. Compute metric suite and failure taxonomy. 5. Review error clusters with domain experts. 6. Update chunking, prompts, or validators. 7. Re-run on unchanged gold set before adding new data. The key is resisting metric drift. If the gold set changes every cycle, your trend lines become hard to trust. Failure taxonomy is as important as scores Raw numbers tell you \"how much.\" Taxonomy tells you \"why.\" Useful failure classes: - condition dropped, - condition mis-scoped, - step merge, - hallucinated transition, - exception omitted, - role misassignment, - source citation missing. When you track these categories over iterations, you can see whether improvements come from real behavior change or from scoring artifacts. Add abstention quality to your dashboard A mature system should know when it is unsure. Track: - abstention rate, - abstention precision (how often abstention was justified), - high-risk false accept rate. In safety-adjacent workflows, a thoughtful abstention is usually better than a confident error with polished prose. Latency and reliability still belong in evaluation Evaluation cannot ignore operational constraints. Even high-quality extraction is unusable if latency is unstable or failures are opaque. Minimum operational metrics: - p50/p95 end-to-end latency, - stage-level latency breakdown, - validation failure rate, - retry and timeout rates, - reproducibility delta across repeated runs. For partner-facing pilots, include these in the same report as semantic metrics. Keeping them separate usually delays integration issues until late stages. A practical release gate template Before promoting a model/pipeline version, require all of the following: - Step F1 above target threshold, - constraint coverage above target threshold, - zero unresolved critical-severity errors on benchmark set, - traceability score above minimum, - latency SLO met at p95, - no regression in top failure classes over previous version. This is stricter than typical ML dashboards. It is also closer to what industrial partners expect once real workflows depend on the system. What I would prioritize next - Better automated scoring for condition scope correctness. - Shared benchmark fragments across organizations without exposing sensitive text. - Confidence calibration that maps to true error likelihood per error class. - Review tools that connect each metric regression to concrete examples immediately. Evaluation is not the final chapter after model building. In applied industrial AI, evaluation is the control loop that decides whether a prototype is trustworthy enough to become a pilot."
    },
    {
      "id": "https://imadlab.me/blogs/designing-local-llm-pipelines-for-industrial-documentation",
      "url": "https://imadlab.me/blogs/designing-local-llm-pipelines-for-industrial-documentation",
      "title": "Designing Local LLM Pipelines for Industrial Documentation",
      "summary": "A field guide for building local document intelligence pipelines when privacy, latency, and traceability are non-negotiable constraints.",
      "tags": [
        "local-llm",
        "industrial-ai",
        "privacy-by-design",
        "systems-engineering",
        "architecture"
      ],
      "date_published": "2026-01-16T07:45:00.000Z",
      "date_modified": "2026-01-16T07:45:00.000Z",
      "content_text": "Industrial documentation is a reliable stress test for LLM engineering discipline. Documents are long, formatting is inconsistent, OCR quality varies, and some of the most important content lives in footnotes, tables, or warning boxes. Now add one more constraint: data cannot leave the organization. At that point, local LLM design stops being a convenience choice and becomes an architecture requirement. Why local is not only a privacy preference Teams often frame local inference as \"we do not want cloud APIs.\" In practice, there are four stronger reasons: - Data boundary control : sensitive operational procedures and incident reports stay on approved infrastructure. - Predictable latency : no external network round-trips for every extraction call. - Operational continuity : the pipeline can continue during external outages or policy restrictions. - Auditability : model versions, prompts, and outputs are tied to internal release workflows. A local stack gives you leverage only if you treat it like infrastructure, not a demo script. Architecture that survives real documents A robust local pipeline usually needs six modules: 1. ingestion and normalization, 2. document segmentation, 3. retrieval and context assembly, 4. extraction, 5. validation, 6. serving and monitoring. Simple diagram: If one of these blocks is missing, the model usually gets blamed for failures that are really pipeline failures. Start with ingestion quality, not model selection I used to begin by swapping models and prompt templates. That was a mistake. For industrial documentation, ingestion quality dominates more than most teams expect. Critical ingestion steps: - normalize line breaks and list markers, - recover heading hierarchy, - preserve table context where thresholds and units live, - keep references between warning blocks and nearby steps. If your text loses this structure early, no model fully recovers it later. Chunking strategy is a first-class design decision Fixed-size chunking is simple and often wrong for procedural text. I get better outcomes with structure-aware chunking: - split by heading and subheading boundaries, - keep list sequences intact, - allow overlap around condition-heavy regions, - use smaller chunk caps for dense safety sections. A good chunking policy reduces both hallucination rate and condition misattachment. Model and runtime choices under hardware limits On local hardware, model selection is a multi-objective tradeoff: - output quality, - latency, - memory pressure, - stability over long contexts. My practical baseline is a quantized 7B-class model with conservative decoding settings. It is rarely perfect, but it is stable enough for fast iteration when paired with a strict validation layer. Typical knobs that matter in production-like settings: - context window tuned to actual chunk profile, - temperature kept low for structured extraction, - output token caps that avoid runaway responses, - deterministic seeds for reproducible comparisons. Validation is where trust is built Without validation, local LLM output is just untrusted text with better formatting. For procedural extraction, I require: - schema validity, - required fields for every step and constraint, - edge sanity checks (no broken references), - source-span evidence for critical constraints. When validation fails, the pipeline should not silently \\\"best effort\\\" the output. It should either repair with explicit rules or abstain and request review. That abstain path looks less impressive in demos and is usually much safer in real operations. Monitoring beyond uptime Most teams monitor service health and call it done. For document intelligence, monitor semantic drift too. Useful counters: - extraction success rate per document type, - average constraints per document over time, - validation failure classes, - manual correction rate in review UI, - latency percentiles by stage. If correction rate spikes after a format change from a partner team, you want to detect it in hours, not months. Human review should be designed, not bolted on People will review outputs anyway. The question is whether your interface helps them do it quickly and safely. A good review surface should show: - extracted step, - linked constraint, - exact source snippet, - reason for validation warning, - one-click correction path. When review takes too long, teams silently skip it. Then confidence decays and adoption stalls. Common mistakes I see in local deployments - treating OCR as solved when table extraction is still brittle, - evaluating only on small clean samples, - overfitting prompts to one document family, - logging too little metadata to debug failures later, - ignoring versioning for prompts and chunking policies. None of these issues are glamorous, but each one creates avoidable rework. What changes when moving from prototype to pilot The biggest shift is accountability. In prototype mode, you optimize for \"can it work.\" In pilot mode, you optimize for \"can we explain and maintain it.\" That means: - explicit data contracts, - traceable release notes, - rollback paths, - clear ownership for model, pipeline, and validation rules. If your system cannot explain why it produced a specific constraint mapping, it is not ready for partner-facing work. Open problems worth solving next - Better local layout parsers for mixed text-table-warning documents. - Confidence calibration for condition extraction under OCR noise. - Lightweight active learning loops using reviewer corrections. - Stronger detection of contradictory constraints across document versions. Local LLM pipelines are not a compromise when they are designed well. In industrial settings, they are often the architecture that makes deployment possible in the first place."
    },
    {
      "id": "https://imadlab.me/blogs/procedural-knowledge-extraction-is-not-summarization",
      "url": "https://imadlab.me/blogs/procedural-knowledge-extraction-is-not-summarization",
      "title": "Procedural Knowledge Extraction Is Not Summarization",
      "summary": "In industrial documentation, a fluent summary can still be operationally wrong. This note explains why procedural extraction needs structure, constraints, and traceable validation.",
      "tags": [
        "procedural-knowledge-extraction",
        "industrial-ai",
        "knowledge-graphs",
        "evaluation",
        "safety"
      ],
      "date_published": "2025-12-29T08:20:00.000Z",
      "date_modified": "2025-12-29T08:20:00.000Z",
      "content_text": "Most teams start procedural extraction with a familiar baseline: summarize each page, stitch the text, and hope the model has captured the process. I did the same at the beginning. The output looked polished, but it failed in the exact places that matter most. That mismatch was one of the first uncomfortable lessons I learned while working with industrial manuals. If the goal is operational support, style quality is almost irrelevant. What matters is whether the system preserves executable logic: order, conditions, exceptions, and responsibility boundaries. A summary can be fluent and still hide a safety-critical branch. A concrete failure pattern Take a typical maintenance instruction: 1. Isolate power. 2. Confirm lockout tag status. 3. If pressure is above threshold, vent line before valve replacement. 4. Replace valve. 5. Record torque value and sign-off. A standard summary usually compresses this into a paragraph about \"safe valve replacement.\" It might keep the broad intent and still lose the conditional step about pressure and venting. To a reader, that omission can look minor. In a plant, it is not minor. That is why I treat procedural extraction as a structured prediction problem, not a text compression problem. What summarization misses The recurring misses are consistent across domains: - Condition fidelity : thresholds, guards, and preconditions disappear first. - Decision points : branch logic gets flattened into linear prose. - Exception handling : warnings, prohibited actions, and fallback paths are dropped. - Role binding : who approves, who executes, and who verifies becomes vague. If your downstream system is a search UI, you might get away with this. If your downstream system informs real operations, you cannot. What to extract instead The extraction target should look like process logic, not paragraph logic. In practice, that means a graph-oriented schema with explicit types. Minimal example: This is not about graph databases for their own sake. The graph is useful because it makes omissions visible. You can inspect missing guards, broken edges, and orphaned conditions directly. Pipeline design that works better The extraction stack that has held up best for me has four explicit phases: 1. Structure-aware chunking : preserve headings, list boundaries, and procedural block integrity. 2. Step extraction first : force a stable ordered skeleton before attempting constraint attachment. 3. Constraint linking second : map warnings, thresholds, and exceptions to specific step IDs. 4. Validation and repair pass : run schema checks and lightweight consistency rules before publish. The reason this staged setup works is simple: it reduces simultaneous ambiguity. If a model tries to infer order, condition scope, and relationship types in one pass, you usually get elegant but fragile output. Evaluation needs to match operational risk Accuracy alone is a weak signal here. You can score high on generic overlap metrics and still fail the safety logic. I recommend tracking at least these dimensions: - Step F1 : are core actions captured. - Adjacency fidelity : are transitions and ordering preserved. - Constraint coverage : what share of required guards and conditions are recovered. - Decision-point fidelity : are branch nodes and branch criteria retained. - Exception recall : are explicit warnings and prohibited actions represented. If I had to choose one \"do not skip\" metric, it is constraint coverage. In industrial procedures, missing constraints cause disproportionate downstream risk. Failure modes worth planning for Three failure modes show up repeatedly even with strong prompts: - Scope leakage : a condition from one subsection gets attached to the wrong step in another subsection. - False merge : two similar steps are collapsed into one generalized action. - Hallucinated bridge : the model inserts a transition that sounds plausible but does not exist in the source. The mitigations are not glamorous, but they are effective: - keep chunk windows smaller around dense condition blocks, - use explicit step IDs during extraction, - require source-span references for every extracted constraint, - reject outputs that fail graph sanity checks. Why this matters beyond one thesis project There is a broader lesson here for applied AI in industry. Fluency can hide structural error. The more polished the output, the easier it is for teams to over-trust it. For decision support, we need systems that are inspectable before they are impressive. That is why my default target is not \"best sounding answer.\" It is an auditable intermediate representation that an engineer can question, debug, and improve over time. Open problems I am actively interested in - Better automatic detection of condition scope boundaries across noisy OCR text. - Severity-aware scoring so missing high-risk constraints is penalized more heavily. - Hybrid extraction with rules plus model inference for stricter guard recovery. - Operator-friendly review interfaces that allow fast correction without schema expertise. If you are building in this space, start with a small, high-quality gold set and one hard requirement: every extracted constraint must point back to source evidence. In my experience, that single decision improves system quality more than most prompt-tuning tricks."
    },
    {
      "id": "https://imadlab.me/blogs/local-llm-apple-silicon-engineering-notes",
      "url": "https://imadlab.me/blogs/local-llm-apple-silicon-engineering-notes",
      "title": "Designing a Small Local LLM Pipeline on Apple Silicon: Engineering Notes",
      "summary": "A practical engineering note on building and evaluating a local transformer pipeline under tight hardware constraints, including failure modes and reliability tradeoffs.",
      "tags": [
        "local-llm",
        "industrial-ai",
        "evaluation",
        "privacy-by-design",
        "systems-engineering"
      ],
      "date_published": "2025-07-11T21:07:09.397Z",
      "date_modified": "2026-02-09T12:18:27.145Z",
      "content_text": "The Spark That Started It All I'll be honest with you, six months ago, I thought building a language model was something only PhD researchers at big tech companies could do. I mean, we're talking about neural networks that can understand and generate human language, right? That's got to be rocket science. But then I stumbled across a YouTube video of someone training a tiny GPT model on Shakespeare's works, and something just clicked. \"What if I could build my own?\" I thought. Not something that would compete with ChatGPT or Claude, but something mine —something I could understand from the ground up. Spoiler alert: it was harder than I expected, but also way more rewarding than I imagined. Why I Decided to Go Local (And Small) Before diving into the technical stuff, let me tell you why I chose to build a small, local model instead of just fine-tuning an existing one. First, privacy . I wanted something that would run entirely on my machine, no data leaving my computer. Second, understanding . I'm the kind of person who needs to know how things work under the hood. And third, constraints breed creativity . With my M4 MacBook Pro and its 16GB of unified memory, I had to get creative about architecture and training. No fancy GPU here—just the neural engine and whatever PyTorch could squeeze out of Metal Performance Shaders. The Technical Journey Step 1: Understanding the Basics I started with the fundamentals. If you're thinking about doing this yourself, don't skip this part like I almost did. I spent two weeks just reading papers and tutorials: - The original \"Attention Is All You Need\" paper (read it three times before it clicked) - Andrej Karpathy's \"makemore\" series (absolute gold) - The nanoGPT repository Pro tip : Don't try to understand everything at once. I made notes in a simple text file, and looking back, some of my early notes make me laugh. \"Attention = somehow the model looks at different parts of the input\" was one of my profound insights. Step 2: Choosing My Architecture I went with a decoder-only transformer architecture, similar to GPT but much smaller. Here's what I settled on: - 6 layers (compared to GPT-3's 96) - 8 attention heads - 384 embedding dimensions - Vocabulary size: 10,000 tokens - Context window: 512 tokens Total parameters? About 10 million. Tiny by today's standards, but perfect for my laptop. Step 3: The Data Dilemma This was my first real challenge. What do you train a small model on? I considered several options: - Wikipedia dumps (too big, too varied) - Books (copyright issues) - My own writing (not enough data) I ended up creating a curated dataset mixing: - Public domain books from Project Gutenberg - Wikipedia articles on topics I cared about - Programming tutorials and documentation - Some Reddit discussions (carefully filtered) Final dataset: about 50MB of text. Small, but focused. Step 4: Implementation Reality Check I initially planned to write everything from scratch in pure Python. That lasted about two days. Here's what I actually ended up using: - PyTorch for the neural network (with MPS backend for M4 acceleration) - Hugging Face tokenizers for text preprocessing - Weights & Biases for experiment tracking - A lot of Stack Overflow for debugging Metal Performance Shaders issues The actual model implementation was about 200 lines of Python. Here's the surprising part: getting PyTorch to properly utilize the M4's neural engine took longer than writing the model itself. Apple's Metal Performance Shaders documentation became my bedtime reading. Step 5: Training Adventures My first training run was a disaster. The loss went to NaN after 100 steps, and I had no idea why. After some debugging (and discovering that MPS has some quirks with certain operations), I found out my learning rate was way too high and I needed to move some operations back to CPU. Training specs: - Batch size : 8 (memory constraints with 16GB shared between system and model) - Learning rate : 3e-4 (after much experimentation) - Training time : 2 days on M4 (surprisingly efficient!) - Final loss : 2.4 (not great, but not terrible) The M4 was actually fantastic for this kind of work. The unified memory architecture meant I could load larger datasets than I expected, and the neural engine handled the matrix operations beautifully once I got the MPS backend working properly. I trained three different versions, each time learning something new: 1. Version 1 : Overfit to the training data 2. Version 2 : Added dropout, but learning rate was still wrong 3. Version 3 : Finally got it right The Moment of Truth After two days of training version 3, I nervously typed my first prompt: \"The future of artificial intelligence\" The output was... underwhelming: The future of artificial intelligence is a complex and multifaceted topic that involves many different aspects of technology and society. In recent years, there has been... It was generic, but it was coherent . My little model was actually generating reasonable text! I may have done a small victory dance in my room. (The M4 stayed remarkably cool throughout this whole process, which was a nice bonus.) What I Learned (The Hard Way) Technical Lessons 1. Learning rate scheduling matters more than I thought . I spent hours tweaking the architecture when the real problem was my learning rate decay. 2. Data quality beats data quantity . My 50MB of curated text worked better than the 500MB of random internet text I tried first. 3. Regularization is crucial . Without proper dropout and weight decay, my model would memorize the training data instead of learning patterns. Personal Lessons 1. Start smaller than you think . My first attempt had 50 million parameters. My successful model had 10 million. 2. Document everything . I wish I'd kept better notes about what worked and what didn't. Future me would thank past me. 3. The community is amazing . I got help from strangers on Reddit, Discord, and Twitter. The ML community really wants to help newcomers. Performance and Limitations Let's be real about what my little model can and can't do: What it's good at: - Writing coherent paragraphs on familiar topics - Completing sentences in a reasonable way - Following basic instruction patterns What it struggles with: - Complex reasoning - Staying on topic for long passages - Anything requiring real-world knowledge - Math (it once told me 2+2=5, very confidently) Lessons for Anyone Thinking About This If you're considering building your own LLM, here's my honest advice: Do it if: - You want to understand how these models really work - You enjoy debugging and experimentation - You have a specific use case in mind - You learn better by doing than reading Don't expect: - To build the next ChatGPT - It to be easy or quick - Perfect results on your first try - To save money compared to using APIs What's Next? I'm already planning version 4. I want to experiment with: - Mixture of Experts architecture - Better tokenization strategies - Instruction tuning on my own dataset - Quantization to make it even more efficient But honestly? The biggest win isn't the model itself—it's the understanding I gained. Every time I use ChatGPT or Claude now, I have a much better appreciation for what's happening under the hood. Final Thoughts Building my own LLM was like learning to cook by growing your own vegetables. Sure, you can buy better results at the store, but there's something magical about the process. Every bug I fixed, every hyperparameter I tuned, every coherent sentence my model generated—it all felt like a small victory. If you're curious about AI and have some programming experience, I'd encourage you to try it. Not because you'll build something revolutionary, but because you'll understand something revolutionary in a completely new way. And who knows? Maybe your small model will surprise you, just like mine surprised me."
    }
  ]
}